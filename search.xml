<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java多线程机制</title>
      <link href="/2019/09/02/java-duo-xian-cheng-ji-zhi/"/>
      <url>/2019/09/02/java-duo-xian-cheng-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><blockquote><p>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程本质是一个执行的程序，比如运行时 QQ、浏览器等。</p></blockquote><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>线程是操作系统能够运算调度的最小单位。线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p></blockquote><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><blockquote><p>当多个线程对同一个共享变量/对象进行操作时，即使是简单的运算，实际上会涉及到读取、运算、赋值等操作，过程中也就会出现时间差，导致多个线程没有按照预定的顺序执行，出现错误。<code>Java</code> 中的多线程通过锁进行同步执行的。</p></blockquote><p>锁机制需要满足两种特性：</p><ul><li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块（复合操作）进行访问。互斥性也成为操作的原子性。</li><li>可见性：确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</li></ul><h3 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h3><blockquote><p><code>Java</code> 语言规范（<code>JLS</code>）定义一个统一的内存模型（<code>JMM</code>）。<code>JMM</code> 规定了 <code>JVM</code> 有主内存和工作内存，主内存存放程序中所有类实例、静态数据等，是多个线程共享的，工作内存存放的是该线程从主内存中复制过来的变量、局部变量等，是线程私有的。</p></blockquote><p><em>由于多个线程不是直接操作主内存中的数据，而是操作各自工作内存中的数据，从而导致了数据不一致性问题。</em></p><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><blockquote><p><code>Thread</code> 类是在 <code>java.lang</code> 包中定义的，继承 <code>Thread</code> 类必须重写 <code>run</code> 方法。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread1 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>程序启动运行 <code>main</code> 方法时，<code>JVM</code> 启动一个进程，主线程在 <code>main()</code> 调用时被创建。</p></blockquote><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread2 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread2 r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>Runnbal</code> 不存在 <code>start()</code> 启动方法，故需要通过 <code>Thread</code> 类的构造函数 <code>Thread(Runnable target)</code>来构造对象，然后调用 <code>Thread</code> 对象的 <code>start()</code> 方法来启动多线程。</p></blockquote><p><em>继承 <code>Thread</code> 类不适合资源共享，而实现 <code>Runnable</code> 接口，则容易实现资源共享。</em></p><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread3</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写call方法。     *     * @return 返回对象     * @throws Exception 异常     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Boolean <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread3 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"发生异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FutureTask ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// get方法获取的是call的返回值。</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>实现 <code>Callable</code> 类可在 <code>call</code> 方法中返回一个值，而且 <code>call</code> 方法可以抛出异常，而实现 <code>Runnable</code> 类在 <code>start</code> 方法没有返回值，也不会抛出异常。</p></blockquote><h4 id="设定优先级"><a href="#设定优先级" class="headerlink" title="设定优先级"></a>设定优先级</h4><blockquote><p>设定优先级并不是100%执行，只是提高线程抢到 <code>CPU</code> 资源的可能性。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 线程名称。</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造器。</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置优先级。</span>        t1<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务机制及原理</title>
      <link href="/2019/08/27/shu-ju-ku-shi-wu-ji-zhi-ji-yuan-li/"/>
      <url>/2019/08/27/shu-ju-ku-shi-wu-ji-zhi-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>以下介绍是基于 <code>MySql</code> 数据库，<code>InnoDB</code> 存储引擎。</p></blockquote><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><blockquote><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部失败。简言之，数据库事务就是将一组 <code>sql</code> 语句组装起来，要么它们一起成功执行，否则全部失败回滚。</p></blockquote><h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">start</span> <span class="token keyword">transaction</span>        <span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">commit</span>                   <span class="token comment" spellcheck="true"># 提交事务</span><span class="token keyword">rollback</span>                 <span class="token comment" spellcheck="true"># 事务回滚</span></code></pre><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li><strong>原子性</strong>：事务是一个不可分割的工作单位，要么一起成功，要么全部失败。</li><li><strong>一致性</strong>：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li><strong>隔离性</strong>：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li><strong>持久性</strong>：事务一旦被提交，它对数据库中数据的改变就是永久性的。</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote><p>多个事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个事务在获取数据时的准确性。</p></blockquote><h4 id="隔离级别分类"><a href="#隔离级别分类" class="headerlink" title="隔离级别分类"></a>隔离级别分类</h4><ul><li><p>Read Uncommitted（读未提交）</p><blockquote><p>允许所有事务可以看到未提交事务的数据，从而会产生脏读，不可重复读和幻像读。这种事务隔离级别最低。</p></blockquote></li><li><p>Read Committed（读已提交，不可重复读）</p><blockquote><p>一个事务不可以读取未提交事务的数据，同样的，一个事务在提交数据后才能被其他事务读取。由于在读取时没有加锁，所以在两次读取过程，如果有事务修改了数据，那么两次的读取内容是不一致的。这也就是不可重复读的原因。</p></blockquote></li><li><p>Repeatable Read（可重复读）</p><blockquote><p>一个事务中多次执行统一读 <code>sql</code>，返回结果一样，解决不可重复读问题。<code>MySql</code> 默认事务隔离级别</p></blockquote></li><li><p>Serializable（可串形化）</p><blockquote><p>使用事务串形化调度，通过强制事务排序，使之不可能相互冲突，它是在每个读的数据行上加上共享锁。可能导致大量的超时和死锁现象。</p></blockquote></li></ul><p><em>查询数据库事务隔离级别 <code>sql</code> 语句</em></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span>           <span class="token comment" spellcheck="true"># 查询当前会话隔离级别</span><span class="token keyword">select</span> @<span class="token variable">@global.tx_isolation</span>    <span class="token comment" spellcheck="true"># 查询系统当前隔离级别</span></code></pre><p><em>设置数据库事务隔离级别 <code>sql</code> 语句</em></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> 隔离级别名  <span class="token comment" spellcheck="true"># 设置当前会话隔离级别</span><span class="token keyword">set</span> <span class="token keyword">global</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> 隔离级别名   <span class="token comment" spellcheck="true"># 设置系统当前隔离级别</span></code></pre><h4 id="隔离性可能的并发问题"><a href="#隔离性可能的并发问题" class="headerlink" title="隔离性可能的并发问题"></a>隔离性可能的并发问题</h4><p><em>事务不考虑隔离性，可能引发的问题。</em></p><ol><li>脏读：一个事务读取了另一个事务未提交的数据。</li><li>不可重复读：一个事务内读取表中某行数据，多次读取结果不一致。<blockquote><p>不可重复读和脏读的区别：脏读是读取前一事务未提交的脏数据，不可重复读是读取前一事务已提交的数据。</p></blockquote></li><li>幻读：一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<blockquote><p>幻读和脏读的区别：脏读是读取事务修改的数据，脏读是读取事务新增的数据。</p></blockquote></li></ol><table><thead><tr><th align="left">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">Read Uncommitted</td><td align="center">可能出现</td><td align="center">可能出现</td><td align="center">可能出现</td></tr><tr><td align="left">Read Committed</td><td align="center">不会出现</td><td align="center">可能出现</td><td align="center">可能出现</td></tr><tr><td align="left">Repeatable Read</td><td align="center">不会出现</td><td align="center">不会出现</td><td align="center">可能出现</td></tr><tr><td align="left">Read Uncommitted</td><td align="center">不会出现</td><td align="center">不会出现</td><td align="center">不会出现</td></tr></tbody></table><h3 id="隔离级别演示"><a href="#隔离级别演示" class="headerlink" title="隔离级别演示"></a>隔离级别演示</h3><ol><li>将数据库事务隔离级别设置成 <code>Read UnCommitted</code> </li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B     </span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 查询账户信息，发现余额多了100，说明读取到了事务B未提交的数据</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 执行后不要提交，执行事务A操作</span><span class="token keyword">update</span> account <span class="token keyword">set</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>将数据库事务隔离级别设置成 <code>Read Committed</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，发现余额多了100，说明读取到了事务B已提交的数据</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 更新账号余额 </span><span class="token keyword">update</span> account <span class="token keyword">set</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 提交事务后，执行事务A操作</span><span class="token keyword">commit</span><span class="token punctuation">;</span>   </code></pre><blockquote><p>这里你可以先不提交执行事务A操作，看是否会查询到事务B未提交的数据，答案是不可以的。大部分数据库隔离级别都是设置为 <code>Read Committed</code>。</p></blockquote><ol start="3"><li>将数据库事务隔离级别设置成 <code>Repeatable Read</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，发现多了1条数据，说明读取到了事务B新增的数据。</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 执行后不要提交，执行事务B操作</span><span class="token keyword">insert</span> account<span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> money<span class="token punctuation">)</span> <span class="token keyword">VALUE</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">1100.00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span></code></pre><blockquote><p>以上实验是建立在数据库未引用 <code>MVVC</code>（一种基于多版本的并发控制协议）基础下的。在 <code>MVVC</code> 机制下，每行数据都有版本号，在查询时至少要找到不大于事务版本号的数据，即使提交了事务B，但是事务A依旧查不到新增加的数据，因为它的版本号比事务A的要大。</p><ul><li><code>MVVC</code> 只能在 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下工作。</li><li>在 <code>READ UNCOMMITED</code> 隔离级别下找不到适合它们事务的行版本，所以不兼容。</li><li>在 <code>Serializable</code> 隔离级别下读操作会锁定它们返回的数据，所以也不兼容。</li></ul></blockquote><ol start="4"><li>将数据库事务隔离级别设置成 <code>Serializable</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 提交事务后，发现事务B执行成功</span><span class="token keyword">commit</span><span class="token punctuation">;</span>                </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 无法插入数据，一直在等待事务B提交</span><span class="token keyword">insert</span> account<span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> money<span class="token punctuation">)</span> <span class="token keyword">VALUE</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">1100.00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><blockquote><p>虽然 <code>Serializable</code> 是最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是也同样会导致大量超时以及争锁的问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/2019/08/19/hashmap-shi-xian-yuan-li/"/>
      <url>/2019/08/19/hashmap-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><code>HashMap</code> 基于 <code>Map</code> 接口实现，元素以键值对的方式存储，并且允许使用 <code>null</code> 键和 <code>null</code> 值，因为 <code>key</code> 不允许重复，因此只能有一个键为 <code>null</code>， <code>HashMap</code> 不能保证放入元素的顺序，它是<strong>无序的</strong>，和放入的顺序并不能相同。<code>HashMap</code> 是<strong>线程不安全</strong>的。</p></blockquote><p>注：<em>有序存储键值对数据时，可以使用 <code>LinkedHashMap</code>；要保证线程安全时，可以使用 <code>ConcurrentHashMap</code>。</em></p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><blockquote><p><code>HashMap</code> 由<strong>数组</strong>和<strong>链表</strong>来实现对数据的存储。<code>HashMap</code> 采用 <code>Entry</code> 数组来存储键值对，每一个键值对组成了一个 <code>Entry</code> 实体，<code>Entry</code> 类实际上是一个单向的链表结构，它具有 <code>Next</code> 指针，可以连接下一个 <code>Entry</code> 实体，以此来解决 <code>Hash</code> 冲突的问题。</p></blockquote><ol><li>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：查找容易，插入和删除困难。</li><li>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：查找困难，插入和删除容易。</li></ol><p>注：<em><code>HashMap</code> 里面实现一个静态内部类 <code>Entry</code>，其重要的属性有 <code>hash</code>，<code>key</code>，<code>value</code>，<code>next</code>。</em></p><p><code>HashMap</code> 存储规则：每个元素存储的是一个链表的头结点。那么一个长度16的数组中，元素是按照什么规则存放到数组中呢。是通过元素的 <code>key</code> 的哈希值（<code>key</code> 的 <code>hashcode</code> 进行二次 <code>hash</code>）对数组长度 - 1的位运算得到存储位置的下标。比如哈希值8（8 &amp; (16 - 1) = 8）、12（12 &amp; (16 - 1) = 12）、40（40 &amp; (16 - 1) = 8）、140（140 &amp; (16 - 1) = 12），所以8和40存储在数组下标为8的位置；12和140存储在数组下标为12的位置。</p><p><code>HashMap</code> 链式数据结构：<code>Entry</code> 类中有一个 <code>next</code> 属性，指向下一个 <code>Entry</code>。比如第一个键值对A进来，通过计算其 <code>key</code> 的 <code>hash</code> 得到的index = 0，记做：<em>Entry[0] = A</em>；此时又有一个键值对B进来，通过计算得到的index也等于0，此时 <code>HashMap</code> 会使得<em>Entry[0] = B</em>，<em>B.next = A</em>；若这时又进来一个键值对C，同样的index等于0，此时 <code>HashMap</code> 会使得<em>Entry[0] = C</em>，<em>C.next = B</em>；index = 0的位置存储了A、B、C三个键值对，它们之间通过 <code>next</code> 这个属性链接在一起，所以<strong>数组中存储的是最后插入的元素，先插入的元素终会被放到Entry链的尾部</strong>，这里你也就明白为什么 <code>HashMap</code> 是无序的了吧。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><blockquote><p>添加元素时，会判断当前元素个数，当大于等于阈值（数组的长度 * 加载因子的值）时，就会自动扩容。扩容就是重新计算容量，但是 <code>Java</code> 中数组是无法自动扩容的，所以需要新的数组代替已有的容量小的数组。</p></blockquote><p><em>比如长度为16的数组，加载因子为0.75，则阈值为 <code>16 * 0.75 = 12</code>，也就是说当元素个数达到12，在添加第13个元素时会进行扩容。即  <code>16 * 2 = 32</code>，那么扩容后的容量是32。这里先抛出一个问题，为什么每次扩容都在原有容量乘以2，继续往下看。</em></p><p>注：<code>HashMap</code> 使用的是懒加载，构造完 <code>HashMap</code> 对象后，只要不进行 <code>put</code> 方法插入元素之前，<code>HashMap</code> 并不会去初始化或者扩容。</p><p>问题：为什么容量大小为2的n次幂效率最好？</p><table><thead><tr><th align="left">&amp; 1111</th><th align="center">8</th><th align="center">9</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="left">hashcode值</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td></tr><tr><td align="left">数组长度 - 1</td><td align="center">1  1  1  1</td><td align="center">1  1  1  1</td><td align="center">1  1  1  0</td><td align="center">1  1  1  0</td></tr><tr><td align="left">结果</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td><td align="center">1  0  0  0</td><td align="center">1  0  0  0</td></tr></tbody></table><p>如上表，左边两组是数组长度为16(2的4次幂)，右边两组是数组长度为15。两组的 <code>hashcode</code> 均为8 和 9，然而与 <code>1110</code> 做位运算时，产生相同的结果，也是会存储到数组的同一个位置上，这就产生了碰撞，8 和 9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，降低了查询的效率。我们还可以发现，当数组长度为15的时候，<code>hashcode</code> 的值会与14（1110）进行位运算，最后一位永远是0，那 <code>0001</code>，<code>0011</code>，<code>0101</code>，<code>1001</code>，<code>1011</code>，<code>0111</code>，<code>1101</code>这几个位置永远都不能存放元素，浪费空间。数组可使用的位置比数组长度小很多，这样会增加碰撞的几率，减慢查询的效率。</p><blockquote><p>数组长度为2的n次幂的时候，不同的 <code>key</code> 算得的 <code>index</code> 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了，所以在存储大容量数据时，最好预先指定容量大小为2的n次幂（其实不指定为2的n次幂的话，HashMap也会以大于且最接近指定值大小的2的n次幂进行初始化），也解释了上面问题，为什么 <code>HashMap</code> 每次扩容都在原有容量上乘以2。</p></blockquote><p>扩容是一个特别耗性能的操作，所以在使用 <code>HashMap</code> 的时候，估算 <code>map</code> 的大小，初始化的时候给一个大致的数值，避免 <code>map</code> 进行频繁的扩容。那么这个数值多少才是最合适的值呢，下面看一个例子。</p><p>例：假如有1000个元素需要存储到 <code>HashMap</code> 中，那么根据上面提到的容量大小为2的n次幂效率最好，那么 <code>new HashMap(1024)</code> 是比较合适的，但是上面也提到了，当存储元素达到阈值时，<code>HashMap</code> 会进行扩容，那么1024 * 0.75 &lt; 1000，所以为了不进行扩展，需要size * 0.75 &gt; 1000，那么可以得出 <code>new HashMap(2048)</code> 才是最合适的。 </p><h3 id="重写-hashcode-和-equals-方法"><a href="#重写-hashcode-和-equals-方法" class="headerlink" title="重写 hashcode 和 equals 方法"></a>重写 hashcode 和 equals 方法</h3><p>疑问：为什么要重写 <code>hashcode</code> 和 <code>equals</code> 方法？</p><p>根据上面介绍，我们知道想查找某个元素，就需要先获取其所在位置，那么首先计算 <code>key</code> 的 <code>hashcode</code>，找到其在数组中对应的位置，然后通过 <code>key</code> 的 <code>equals</code> 方法在对应位置的链表中找到元素。因此 <code>hashcode</code> 与 <code>equals</code> 方法对于找到对应元素是两个关键方法。 </p><p>重写 <code>equals</code> 方法需要满足三个条件：</p><ol><li>自反性：a.equals(a) == true。 </li><li>对称性：a.equals(b) == true时，b.equals(a) 也为 true。 </li><li>传递性：a.equals(b) == true时，且b.equals(c) == true，那么 a.equals(c) 也要为 true。 </li></ol><h3 id="JDK-1-8-优化"><a href="#JDK-1-8-优化" class="headerlink" title="JDK 1.8 优化"></a>JDK 1.8 优化</h3><blockquote><p>以上都是基于 <code>JDK 1.7</code> 进行分析的，<code>JDK 1.8</code> 在 <code>HashMap</code> 实现方式上做了一些优化。数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，当链表长度超过阈值（8）时，将链表转换为红黑树。性能上有了提升。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2019/08/14/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2019/08/14/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></h3><blockquote><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></h3><blockquote><p><code>GitHub</code> 是一个面向开源及私有软件项目的托管平台，因为只支持 <code>git</code> 作为唯一的版本库格式进行托管，故名 <code>GitHub</code>。</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="检查是否安装-Git，在-Dos-窗口下，执行下面命令。"><a href="#检查是否安装-Git，在-Dos-窗口下，执行下面命令。" class="headerlink" title="检查是否安装 Git，在 Dos 窗口下，执行下面命令。"></a>检查是否安装 <code>Git</code>，在 <code>Dos</code> 窗口下，执行下面命令。</h5><pre class=" language-dos"><code class="language-dos">git --version</code></pre><h5 id="检查是否安装-Node-js，在-Dos-窗口下，执行下面命令。"><a href="#检查是否安装-Node-js，在-Dos-窗口下，执行下面命令。" class="headerlink" title="检查是否安装 Node.js，在 Dos 窗口下，执行下面命令。"></a>检查是否安装 <code>Node.js</code>，在 <code>Dos</code> 窗口下，执行下面命令。</h5><pre class=" language-dos"><code class="language-dos">node -v</code></pre><blockquote><p> 如果没有安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>和<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a>，到官网自行下载安装，这里不作过多介绍，网上教程也比较多。安装过 <code>Git</code>，以下命令操作都统一使用 <code>Git Bash Here</code> 执行。</p></blockquote><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><h5 id="1-安装-Hexo-扩展插件，在-Git-Bash-Here-窗口下，执行下面命令。"><a href="#1-安装-Hexo-扩展插件，在-Git-Bash-Here-窗口下，执行下面命令。" class="headerlink" title="1. 安装 Hexo 扩展插件，在 Git Bash Here 窗口下，执行下面命令。"></a>1. 安装 <code>Hexo</code> 扩展插件，在 <code>Git Bash Here</code> 窗口下，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g</code></pre><h5 id="2-创建一个-blog-文件夹，存放-hexo-相应的代码。"><a href="#2-创建一个-blog-文件夹，存放-hexo-相应的代码。" class="headerlink" title="2. 创建一个 blog 文件夹，存放 hexo 相应的代码。"></a>2. 创建一个 <code>blog</code> 文件夹，存放 <code>hexo</code> 相应的代码。</h5><pre class=" language-bash"><code class="language-bash">$ hexo init blog</code></pre><h5 id="3-进入-blog-文件夹。"><a href="#3-进入-blog-文件夹。" class="headerlink" title="3. 进入 blog 文件夹。"></a>3. 进入 <code>blog</code> 文件夹。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> blog</code></pre><h5 id="4-安装-hexo-相关代码。"><a href="#4-安装-hexo-相关代码。" class="headerlink" title="4. 安装 hexo 相关代码。"></a>4. 安装 <code>hexo</code> 相关代码。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>下面介绍下相关文件</p><pre class=" language-yaml"><code class="language-yaml">node_modules          npm 文件缓存目录scaffolds             文夹件下存放的是文章、页面模版scource               文夹件下存放的是我们的资源文件themes                文件下存放的是我们的主题文件.gitignore            git 忽略文件，设置提交文件时，哪些文件不提交_config.yml           站点配置文件package.json          站点版本，站点依赖文件package<span class="token punctuation">-</span>lock.json   npm 各库包的依赖</code></pre><h5 id="5-启动本地服务，打开-http-localhost-40000-则可以看到博客雏形了。"><a href="#5-启动本地服务，打开-http-localhost-40000-则可以看到博客雏形了。" class="headerlink" title="5. 启动本地服务，打开 http://localhost:40000 则可以看到博客雏形了。"></a>5. 启动本地服务，打开 <a href="http://localhost:40000/" target="_blank" rel="noopener">http://localhost:40000</a> 则可以看到博客雏形了。</h5><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><h3 id="修改-Hexo-主题"><a href="#修改-Hexo-主题" class="headerlink" title="修改 Hexo 主题"></a>修改 Hexo 主题</h3><h5 id="1-将主题拉到本地，并解压，执行下面命令。"><a href="#1-将主题拉到本地，并解压，执行下面命令。" class="headerlink" title="1. 将主题拉到本地，并解压，执行下面命令。"></a>1. 将主题拉到本地，并解压，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> themes$ <span class="token function">git</span> clone hexo主题GitHub地址</code></pre><h5 id="2-配置-config-yml-的-theme-配置。"><a href="#2-配置-config-yml-的-theme-配置。" class="headerlink" title="2. 配置 _config.yml 的 theme 配置。"></a>2. 配置 <code>_config.yml</code> 的 <code>theme</code> 配置。</h5><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> hexo主题文件夹名</code></pre><h5 id="3-启动站点，执行下面命令。"><a href="#3-启动站点，执行下面命令。" class="headerlink" title="3. 启动站点，执行下面命令。"></a>3. 启动站点，执行下面命令。</h5><pre class=" language-yaml"><code class="language-yaml">cd ..  <span class="token comment" spellcheck="true">#回退到blog文件夹</span>hexo g <span class="token comment" spellcheck="true"># 或者 hexo generate</span>hexo s</code></pre><blockquote><p> 运行上述命令后，浏览器打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可本地访问我们的网站。相关配置修改可以参考你选择的 <code>hexo</code> 主题介绍。<br> 这时候你肯定会问现在博客只能本地访问，那如何能放到网上让其他人也可以访问我的博客呢？下面我们就用 <code>GitHub</code> 来充当我们的服务器，如果你还没有 <code>GitHub</code> 账号，此时你需要注册一个，网上教程很多，这里就不介绍了。</p></blockquote><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><h5 id="1-点击右上角-号，然后点击-New-repository-添加仓库。"><a href="#1-点击右上角-号，然后点击-New-repository-添加仓库。" class="headerlink" title="1. 点击右上角 + 号，然后点击  New repository 添加仓库。"></a>1. 点击右上角 <code>+</code> 号，然后点击  <code>New repository</code> 添加仓库。</h5><p><img src="http://chuantu.xyz/t6/702/1565790257x2890171739.png" alt></p><h5 id="2-打开网址-https-Ownner-gihub-io-则可以看到你的-GitHub-Page，这个就是你的-服务器"><a href="#2-打开网址-https-Ownner-gihub-io-则可以看到你的-GitHub-Page，这个就是你的-服务器" class="headerlink" title="2. 打开网址 https://Ownner.gihub.io 则可以看到你的 GitHub Page，这个就是你的 服务器"></a>2. 打开网址 <a href="https://Ownner.gihub.io" target="_blank" rel="noopener">https://Ownner.gihub.io</a> 则可以看到你的 <code>GitHub Page</code>，这个就是你的 <code>服务器</code></h5><blockquote><p><code>Owner</code> 需要改成你自己的用户名，像我的则是 <code>tongtong-ge</code>。</p></blockquote><h3 id="修改网站相关设置"><a href="#修改网站相关设置" class="headerlink" title="修改网站相关设置"></a>修改网站相关设置</h3><blockquote><p>网站相关设置需要在 <code>_config.yml</code> 里进行修改。对应目录为 <code>blog/_config.yml</code>。找到 <code>GitHub</code> 仓库对应的 <code>SSH</code> 地址，把 <code>SSH</code> 地址添加到 <code>depoly</code>-<code>repo</code> 配置上。</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git   <span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>Owner.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><h3 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h3><h5 id="1-生成静态文件，执行下面命令。"><a href="#1-生成静态文件，执行下面命令。" class="headerlink" title="1. 生成静态文件，执行下面命令。"></a>1. 生成静态文件，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ hexo g</code></pre><h5 id="2-提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。"><a href="#2-提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。" class="headerlink" title="2. 提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。"></a>2. 提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save <span class="token comment" spellcheck="true">#安装扩展插件</span>$ hexo d <span class="token comment" spellcheck="true">#提交到远程仓库</span></code></pre><blockquote><p>执行完之后，此时你就可以在 <code>GitHub</code> 上看到提交的静态文件，同时通过 <a href="https://Owner.github.io" target="_blank" rel="noopener">https://Owner.github.io</a> 就可以访问我们的博客了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/14/hello-world/"/>
      <url>/2019/08/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
