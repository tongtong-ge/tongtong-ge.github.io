<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql索引使用介绍</title>
      <link href="/2019/11/21/mysql-suo-yin-shi-yong/"/>
      <url>/2019/11/21/mysql-suo-yin-shi-yong/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>以下介绍是基于 <code>MySql</code> 数据库，<code>InnoDB</code> 存储引擎。</p></blockquote><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><blockquote><p>索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。</p></blockquote><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><blockquote><p>在 <code>InnoDB</code> 中，表数据文件本身就是按 <code>B+Tree</code> 组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的 <code>key</code> 是数据表的主键，因此 <code>InnoDB</code> 表数据文件本身就是主索引。</p></blockquote><p>注：叶节点包含了完整的数据记录，这种索引叫做聚集索引，因为 <code>InnoDB</code> 的数据文件本身要按主键聚集，所以 <code>InnoDB</code> 要求表必须有主键，如果没有显式指定，则 <code>MySql</code> 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则<code>MySql</code> 自动为 <code>InnoDB</code> 表生成一个隐含字段作为主键。</p><p><strong>辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong></p><h3 id="建立索引注意事项"><a href="#建立索引注意事项" class="headerlink" title="建立索引注意事项"></a>建立索引注意事项</h3><ul><li><p>索引并非越多越好，因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，<code>MySql</code> 在运行时也要消耗资源维护索引。</p></li><li><p>尽量选择区分度高的列作为索引,区分度的公式是 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1。</p></li><li><p>尽量的扩展索引，不要新建索引。比如表中已经有<code>a</code>的索引，现在要加<code>(a,b)</code>的索引，那么只需要修改原来的索引即可，当然要考虑原有数据和线上使用情况（最佳前缀特性）。</p></li><li><p>经常与其他表进行连接的表，在连接字段上应该建立索引。</p></li></ul><h3 id="使用索引注意事项"><a href="#使用索引注意事项" class="headerlink" title="使用索引注意事项"></a>使用索引注意事项</h3><ul><li><p>最佳前缀特性：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> sutdent_info <span class="token keyword">where</span> sex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果在 <code>sex</code> 和 <code>age</code> 两列上创建复合索引将会带来更高的效率。如果创建 <code>(sex, age, grade)</code> 复合索引，那么相当于创建了<code>(sex)</code> 、 <code>(sex, age)</code> 和 <code>(sex, age, grade)</code> 三个索引。因此在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</p></blockquote></li><li><p>不要在列上进行运算</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student_info <span class="token keyword">where</span> MONTH<span class="token punctuation">(</span>birthday<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre><blockquote><p>索引列上进行运算时，索引将不起作用。</p></blockquote></li><li><p>不要左模糊查询</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student_info <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'%三'</span><span class="token punctuation">;</span></code></pre><blockquote><p>若 <code>name</code> 字段创建了索引，此时进行左模糊查询时，索引将不起作用。</p></blockquote></li><li><p>不要隐式转化</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student_info <span class="token keyword">where</span> student_no <span class="token operator">=</span> <span class="token number">20190923433</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果 <code>student_no</code> 字段类型是字符串，但传入条件是数字，将会进行隐式转化，会导致索引无效。</p></blockquote></li><li><p><code>join</code> 语句中条件字段类型需一致</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> class_info <span class="token number">c</span><span class="token keyword">join</span> student_info s <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>class_no <span class="token operator">=</span> s<span class="token punctuation">.</span>class_no<span class="token keyword">where</span> <span class="token number">c</span><span class="token punctuation">.</span>class_no <span class="token operator">=</span> <span class="token number">20190923433</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果 <code>class_info</code> 表和 <code>student_info</code> 表中的<code>class_no</code> 字段类型不一致，会导致索引无效。</p></blockquote></li></ul><h3 id="Sql语句优化"><a href="#Sql语句优化" class="headerlink" title="Sql语句优化"></a>Sql语句优化</h3><ul><li>避免回表<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">#偏移量越大，越往后，查询速度越慢。</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student_info <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre></li></ul><p>#优化后<br>select a.* from student_info s, (select student_no from student_info limit 1000000, 100) b<br>where a.student_no = b.student_no;</p><pre><code>&gt; 上面这种也是分页查询语句的一种优化方式，先查询主键，再通过主键查询数据，将提高查询速度。- 减少子查询的结果集- 永远用小结果集驱动大的结果集，让驱动表的结果集尽可能的小&gt; 小表驱动大表，join查询有在索引条件下，驱动表有索引不会使用索引，被驱动表建立索引会使用索引。在以小表驱动大表的情况下，再给大表建立索引会大大提高执行速度，给被驱动表建立索引。- 不要轻易使用`select *`&gt; `select *` 会更多的消耗`CPU`、内存、`IO`、网络带宽。只取需要的列。### 索引的增、删、改和查```sql#创建索引CREATE INDEX idx_student_no ON student_info(student_no);ALTER TABLE student_info ADD INDEX idx_student_no(trade_no);#删除索引DROP INDEX idx_student_no ON student_info;ALTER TABLE student_info DROP INDEX idx_student_no;#修改索引ALTER TABLE student_info ADD INDEX idx_student_no(student_id);#查看索引SHOW INDEX FROM student_info;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="/2019/09/29/java-xian-cheng-chi/"/>
      <url>/2019/09/29/java-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><ul><li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li><li>能有效控制线程池的最大并发数，避免大量线程之间因互相抢夺系统资源而导致的阻塞现象。</li><li>能够对线程进行简单的管理，并提供定时执行以及指向间隔循环执行等功能。</li></ul><h3 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h3><h4 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h4><blockquote><p>直接调用<code>Executors</code>中相应的便捷方法，比如<code>Executors.newSingleThreadExecutor()</code>。<code>Executors</code>创建线程池便捷方法列表如下：</p></blockquote><table><thead><tr><th align="left">方法名</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">SingleThreadExecutor()</td><td align="left">创建只有一个线程的线程池</td></tr><tr><td align="left">FixedThreadPool(int nThreads)</td><td align="left">创建固定大小的线程池</td></tr><tr><td align="left">CachedThreadPool()</td><td align="left">创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table><blockquote><p>如果你阅读过阿里巴巴Java开发手册，你会看到对于并发处理中有个强制约束是线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。开发手册给出的理由如下：</p></blockquote><ol><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>：<br> 允许的请求队列长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致OOM(内存耗尽)。</li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>：<br> 允许的创建线程数量为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致OOM。</li></ol><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><blockquote><p>构造一个线程池7个参数，这些参数中，<code>corePoolSize</code>和<code>keepAliveTime</code>需要大于等于0，<code>maximumPoolSize</code>大于0且大于<code>corePoolSize</code>，否则会抛出<code>IllegalArgumentException</code>异常。<code>workQueue</code>，<code>threadFactory</code>和<code>handler</code>不能为null，否则会抛出空指针异常。<br><code>corePoolSize</code>和<code>maximumPoolSize</code>设置不当会影响效率，甚至耗尽线程。<br><code>workQueue</code>设置不当容易导致<code>OOM</code>。<br><code>handler</code>设置不当会导致提交任务时抛出异常。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ThreadPoolExecutor的构造器。 * * @param corePoolSize 线程池中长期保留的线程数，即使线程处于空闲状态，也不会回收 *                     (除非设置了allowCoreThreadTimeOut)。 * @param maximumPoolSize 线程池中允许的最大线程数(要大于等于corePoolSize) * @param keepAliveTime 线程数大于corePoolSize时，多余空闲线程在终止前等待新任务的最长时间 *                      (超过这个时间，多余空闲线程将会被回收)。 * @param unit keepAliveTime参数的时间单位。 * @param workQueue 在执行任务之前保存任务的队列(此队列仅包含由execute方法提交的runnable任务)。 * @param threadFactory 创建新线程的方式。 * @param handler 达到线程边界和队列容量而阻止执行时要使用的处理程序(拒绝策略)。 */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span></code></pre><h4 id="工作顺序"><a href="#工作顺序" class="headerlink" title="工作顺序"></a>工作顺序</h4><ol><li>如果运行的线程少于<code>corePoolSize</code>，则执行器总是倾向于添加新线程，而不是排队。</li><li>如果<code>corePoolSize</code>或更多线程正在运行，则执行器总是倾向于将请求排队，而不是添加新线程。</li><li>如果请求不能排队，则创建一个新线程，除非该线程超过<code>maximumPoolSize</code>，在这种情况下，任务将被拒绝。</li></ol><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><blockquote><p>任务队列总有占满的时候，这时候再提交新的任务时，需要有一个处理策略，<code>RejectedExecutionHandler</code>接口为我们提供了控制方式。4种常见的拒绝策略。</p></blockquote><table><thead><tr><th align="left">拒绝策略</th><th align="left">拒绝行为</th></tr></thead><tbody><tr><td align="left">AbortPolicy</td><td align="left">抛出RejectedExecutionException</td></tr><tr><td align="left">DiscardPolicy</td><td align="left">什么也不做，直接忽略</td></tr><tr><td align="left">DiscardOldestPolicy</td><td align="left">丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td align="left">CallerRunsPolicy</td><td align="left">直接由提交任务者执行这个任务</td></tr></tbody></table><p><em>线程池默认拒绝策略是AbortPolicy，抛出RejectedExecutionException异常，该异常是非受检异常，很容易忘记捕获，其实如果不关心被拒绝任务的事件，我们可以将拒绝策略设置成DiscardPolicy，这样多余的任务会被忽略。</em></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 指定拒绝策略 DiscardPolicy。</span>ExecutorService executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                 <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程安全问题</title>
      <link href="/2019/09/17/java-duo-xian-cheng-an-quan-wen-ti/"/>
      <url>/2019/09/17/java-duo-xian-cheng-an-quan-wen-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多线程安全问题，是由于多个线程在访问共享的数据（共享的资源），并且操作共享数据的语句不止一条。那么在多条操作共享数据的之间线程就可能发生切换。只要切换就有安全问题，那么我们就可以把同步加在这些操作共享数据的代码上。</p></blockquote><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><blockquote><p><code>volatile</code> 关键字的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。使用 <code>volatile</code> 关键字增加了实例变量在多个线程间的可见性。但它有个缺点就是不支持原子性。</p></blockquote><p><em>为什么volatile无法保证 i++ 原子性</em></p><blockquote><p>上面提到多线程安全问题原因，操作共享数据的语句不止一条时，那么在多条操作共享数据的之间线程就可能发生切换，这样就会存在安全问题。对于 <code>i++</code> ，可以看做 <code>i = i + 1</code>，那么 <code>i++</code> 实际就是先从内存中读取变量 <code>i</code>，计算 <code>i</code> 的值，再将 <code>i</code> 的值写入内存中。 </p></blockquote><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><blockquote><p><code>synchronized</code> 是为了解决共享资源竞争问题，它的作用是让线程获取对象的同步锁。</p></blockquote><h5 id="同步代码块（synchronized）"><a href="#同步代码块（synchronized）" class="headerlink" title="同步代码块（synchronized）"></a>同步代码块（synchronized）</h5><blockquote><p>同步代码块是一种细粒度锁，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定，任何时候只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。<code>锁对象可以是任意的对象</code>。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 锁对象。</span>Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//TODO</span>    可能会产生线程安全问题的代码<span class="token punctuation">}</span></code></pre><h5 id="同步方法-（synchronized）"><a href="#同步方法-（synchronized）" class="headerlink" title="同步方法 （synchronized）"></a>同步方法 （synchronized）</h5><blockquote><p>同步方法是一种粗粒度锁，无需显式指定同步监视器，同步方法的同步监视器是 <code>this</code>，也就是调用该方法的对象。<code>锁对象是 this</code>。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//TODO</span>    可能会产生线程安全问题的代码<span class="token punctuation">}</span></code></pre><blockquote><p>静态同步方法锁对象是本类名<code>.class</code>。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//TODO</span>    可能会产生线程安全问题的代码<span class="token punctuation">}</span></code></pre><h5 id="synchronized基本原则"><a href="#synchronized基本原则" class="headerlink" title="synchronized基本原则"></a>synchronized基本原则</h5><p>当一个线程访问某对象的 <code>synchronized</code> 方法或者 <code>synchronized</code> 代码块时：</p><ol><li>其他线程对该对象的该 <code>synchronized</code> 方法或者 <code>synchronized</code> 代码块的访问将被阻塞。 </li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 锁对象。</span>    Object lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-bash"><code class="language-bash">Thread-0 -<span class="token operator">></span> 0Thread-0 -<span class="token operator">></span> 1Thread-0 -<span class="token operator">></span> 2Thread-0 -<span class="token operator">></span> 3Thread-0 -<span class="token operator">></span> 4Thread-1 -<span class="token operator">></span> 0Thread-1 -<span class="token operator">></span> 1Thread-1 -<span class="token operator">></span> 2Thread-1 -<span class="token operator">></span> 3Thread-1 -<span class="token operator">></span> 4</code></pre><ol start="2"><li>其他线程仍然可以访问该对象的非同步代码块。 </li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 锁对象。</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Object LOCK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token function">syncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token function">unSyncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 同步方法。 * * @throws Exception 抛出异常 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">syncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 休眠100ms。</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 非同步方法。 * * @throws Exception 抛出异常 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unSyncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 休眠100ms。</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-bash"><code class="language-bash">Thread-1 -<span class="token operator">></span> 0Thread-0 -<span class="token operator">></span> 0Thread-1 -<span class="token operator">></span> 1Thread-0 -<span class="token operator">></span> 1Thread-0 -<span class="token operator">></span> 2Thread-1 -<span class="token operator">></span> 2Thread-0 -<span class="token operator">></span> 3Thread-1 -<span class="token operator">></span> 3Thread-0 -<span class="token operator">></span> 4Thread-1 -<span class="token operator">></span> 4</code></pre><ol start="3"><li>其他线程对该对象的其他的<code>synchronized</code> 方法或者 <code>synchronized</code> 代码块的访问将被阻塞。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 锁对象。</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Object LOCK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token function">syncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            <span class="token function">syncMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 同步方法。 * * @throws Exception 抛出异常 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">syncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 休眠100ms。</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 同步方法2。 * * @throws Exception 抛出异常 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">syncMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 休眠100ms。</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" -> "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre class=" language-bash"><code class="language-bash">Thread-0 -<span class="token operator">></span> 0Thread-0 -<span class="token operator">></span> 1Thread-0 -<span class="token operator">></span> 2Thread-0 -<span class="token operator">></span> 3Thread-0 -<span class="token operator">></span> 4Thread-1 -<span class="token operator">></span> 0Thread-1 -<span class="token operator">></span> 1Thread-1 -<span class="token operator">></span> 2Thread-1 -<span class="token operator">></span> 3Thread-1 -<span class="token operator">></span> 4</code></pre><p><em>volatile与synchronize区别</em></p><ul><li>多线程访问时，<code>volatile</code> 不会发生阻塞，但是 <code>synchronize</code> 会发生阻塞。</li><li><code>volatile</code> 属于轻量级实现，因此 <code>volatile</code> 性能比 <code>synchronize</code> 性能好。<code>synchronize</code>可以修饰方法和代码块，而 <code>volatile</code> 只能修饰变量。</li><li><code>volatile</code> 能保证数据的可见性，但不能保证原子性；<code>synchronized</code> 既可以保证原子性，也可以保证可见性。</li><li><code>volatile</code> 解决的是变量在多个线程之间的可见性，而 <code>synchronized</code> 解决的是多个线程之间访问资源的同步性。</li></ul><h4 id="同步锁-Lock"><a href="#同步锁-Lock" class="headerlink" title="同步锁 Lock"></a>同步锁 Lock</h4><blockquote><p>使用同步锁 <code>Lock</code> 一定要解锁，将解锁放在 <code>finall</code> 中，即使程序出现异常也会解锁，也不会造成一直占用锁资源。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建Lock锁对象。</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 上锁。</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//TODO</span>                可能会产生线程安全问题的代码            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 解锁。</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 同步锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程机制</title>
      <link href="/2019/09/02/java-duo-xian-cheng-ji-zhi/"/>
      <url>/2019/09/02/java-duo-xian-cheng-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><blockquote><p>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程本质是一个执行的程序，比如运行时 QQ、浏览器等。</p></blockquote><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>线程是操作系统能够运算调度的最小单位。线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p></blockquote><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><blockquote><p>当多个线程对同一个共享变量/对象进行操作时，即使是简单的运算，实际上会涉及到读取、运算、赋值等操作，过程中也就会出现时间差，导致多个线程没有按照预定的顺序执行，出现错误。<code>Java</code> 中的多线程通过锁进行同步执行的。</p></blockquote><p>锁机制需要满足两种特性：</p><ul><li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块（复合操作）进行访问。互斥性也成为操作的原子性。</li><li>可见性：确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</li></ul><h3 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h3><blockquote><p><code>Java</code> 语言规范（<code>JLS</code>）定义一个统一的内存模型（<code>JMM</code>）。<code>JMM</code> 规定了 <code>JVM</code> 有主内存和工作内存，主内存存放程序中所有类实例、静态数据等，是多个线程共享的，工作内存存放的是该线程从主内存中复制过来的变量、局部变量等，是线程私有的。</p></blockquote><p><em>由于多个线程不是直接操作主内存中的数据，而是操作各自工作内存中的数据，从而导致了数据不一致性问题。</em></p><h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><blockquote><p><code>Thread</code> 类是在 <code>java.lang</code> 包中定义的，继承 <code>Thread</code> 类必须重写 <code>run</code> 方法。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread1</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread1 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>程序启动运行 <code>main</code> 方法时，<code>JVM</code> 启动一个进程，主线程在 <code>main()</code> 调用时被创建。</p></blockquote><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread2</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread2 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread2 r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>Runnbal</code> 不存在 <code>start()</code> 启动方法，故需要通过 <code>Thread</code> 类的构造函数 <code>Thread(Runnable target)</code>来构造对象，然后调用 <code>Thread</code> 对象的 <code>start()</code> 方法来启动多线程。</p></blockquote><p><em>继承 <code>Thread</code> 类不适合资源共享，而实现 <code>Runnable</code> 接口，则容易实现资源共享。</em></p><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread3</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 重写call方法。     *     * @return 返回对象     * @throws Exception 异常     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Boolean <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread3 running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"发生异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FutureTask ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// get方法获取的是call的返回值。</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>实现 <code>Callable</code> 类可在 <code>call</code> 方法中返回一个值，而且 <code>call</code> 方法可以抛出异常，而实现 <code>Runnable</code> 类在 <code>start</code> 方法没有返回值，也不会抛出异常。</p></blockquote><h4 id="设定优先级"><a href="#设定优先级" class="headerlink" title="设定优先级"></a>设定优先级</h4><blockquote><p>设定优先级并不是100%执行，只是提高线程抢到 <code>CPU</code> 资源的可能性。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 线程名称。</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造器。</span>    <span class="token keyword">public</span> <span class="token function">MyThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写run方法。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置优先级。</span>        t1<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务机制及原理</title>
      <link href="/2019/08/27/shu-ju-ku-shi-wu-ji-zhi-ji-yuan-li/"/>
      <url>/2019/08/27/shu-ju-ku-shi-wu-ji-zhi-ji-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>以下介绍是基于 <code>MySql</code> 数据库，<code>InnoDB</code> 存储引擎。</p></blockquote><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><blockquote><p>事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部失败。简言之，数据库事务就是将一组 <code>sql</code> 语句组装起来，要么它们一起成功执行，否则全部失败回滚。</p></blockquote><h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">start</span> <span class="token keyword">transaction</span>        <span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">commit</span>                   <span class="token comment" spellcheck="true"># 提交事务</span><span class="token keyword">rollback</span>                 <span class="token comment" spellcheck="true"># 事务回滚</span></code></pre><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li><strong>原子性</strong>：事务是一个不可分割的工作单位，要么一起成功，要么全部失败。</li><li><strong>一致性</strong>：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li><strong>隔离性</strong>：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li><strong>持久性</strong>：事务一旦被提交，它对数据库中数据的改变就是永久性的。</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><blockquote><p>多个事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个事务在获取数据时的准确性。</p></blockquote><h4 id="隔离级别分类"><a href="#隔离级别分类" class="headerlink" title="隔离级别分类"></a>隔离级别分类</h4><ul><li><p>Read Uncommitted（读未提交）</p><blockquote><p>允许所有事务可以看到未提交事务的数据，从而会产生脏读，不可重复读和幻像读。这种事务隔离级别最低。</p></blockquote></li><li><p>Read Committed（读已提交，不可重复读）</p><blockquote><p>一个事务不可以读取未提交事务的数据，同样的，一个事务在提交数据后才能被其他事务读取。由于在读取时没有加锁，所以在两次读取过程，如果有事务修改了数据，那么两次的读取内容是不一致的。这也就是不可重复读的原因。</p></blockquote></li><li><p>Repeatable Read（可重复读）</p><blockquote><p>一个事务中多次执行统一读 <code>sql</code>，返回结果一样，解决不可重复读问题。<code>MySql</code> 默认事务隔离级别</p></blockquote></li><li><p>Serializable（可串形化）</p><blockquote><p>使用事务串形化调度，通过强制事务排序，使之不可能相互冲突，它是在每个读的数据行上加上共享锁。可能导致大量的超时和死锁现象。</p></blockquote></li></ul><p><em>查询数据库事务隔离级别 <code>sql</code> 语句</em></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span>           <span class="token comment" spellcheck="true"># 查询当前会话隔离级别</span><span class="token keyword">select</span> @<span class="token variable">@global.tx_isolation</span>    <span class="token comment" spellcheck="true"># 查询系统当前隔离级别</span></code></pre><p><em>设置数据库事务隔离级别 <code>sql</code> 语句</em></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> 隔离级别名  <span class="token comment" spellcheck="true"># 设置当前会话隔离级别</span><span class="token keyword">set</span> <span class="token keyword">global</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> 隔离级别名   <span class="token comment" spellcheck="true"># 设置系统当前隔离级别</span></code></pre><h4 id="隔离性可能的并发问题"><a href="#隔离性可能的并发问题" class="headerlink" title="隔离性可能的并发问题"></a>隔离性可能的并发问题</h4><p><em>事务不考虑隔离性，可能引发的问题。</em></p><ol><li>脏读：一个事务读取了另一个事务未提交的数据。</li><li>不可重复读：一个事务内读取表中某行数据，多次读取结果不一致。<blockquote><p>不可重复读和脏读的区别：脏读是读取前一事务未提交的脏数据，不可重复读是读取前一事务已提交的数据。</p></blockquote></li><li>幻读：一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<blockquote><p>幻读和脏读的区别：脏读是读取事务修改的数据，脏读是读取事务新增的数据。</p></blockquote></li></ol><table><thead><tr><th align="left">事务隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">Read Uncommitted</td><td align="center">可能出现</td><td align="center">可能出现</td><td align="center">可能出现</td></tr><tr><td align="left">Read Committed</td><td align="center">不会出现</td><td align="center">可能出现</td><td align="center">可能出现</td></tr><tr><td align="left">Repeatable Read</td><td align="center">不会出现</td><td align="center">不会出现</td><td align="center">可能出现</td></tr><tr><td align="left">Read Uncommitted</td><td align="center">不会出现</td><td align="center">不会出现</td><td align="center">不会出现</td></tr></tbody></table><h3 id="隔离级别演示"><a href="#隔离级别演示" class="headerlink" title="隔离级别演示"></a>隔离级别演示</h3><ol><li>将数据库事务隔离级别设置成 <code>Read UnCommitted</code> </li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B     </span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 查询账户信息，发现余额多了100，说明读取到了事务B未提交的数据</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 执行后不要提交，执行事务A操作</span><span class="token keyword">update</span> account <span class="token keyword">set</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>将数据库事务隔离级别设置成 <code>Read Committed</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，发现余额多了100，说明读取到了事务B已提交的数据</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 更新账号余额 </span><span class="token keyword">update</span> account <span class="token keyword">set</span> money <span class="token operator">=</span> money <span class="token operator">+</span> <span class="token number">100</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 提交事务后，执行事务A操作</span><span class="token keyword">commit</span><span class="token punctuation">;</span>   </code></pre><blockquote><p>这里你可以先不提交执行事务A操作，看是否会查询到事务B未提交的数据，答案是不可以的。大部分数据库隔离级别都是设置为 <code>Read Committed</code>。</p></blockquote><ol start="3"><li>将数据库事务隔离级别设置成 <code>Repeatable Read</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，发现多了1条数据，说明读取到了事务B新增的数据。</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 执行后不要提交，执行事务B操作</span><span class="token keyword">insert</span> account<span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> money<span class="token punctuation">)</span> <span class="token keyword">VALUE</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">1100.00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span></code></pre><blockquote><p>以上实验是建立在数据库未引用 <code>MVVC</code>（一种基于多版本的并发控制协议）基础下的。在 <code>MVVC</code> 机制下，每行数据都有版本号，在查询时至少要找到不大于事务版本号的数据，即使提交了事务B，但是事务A依旧查不到新增加的数据，因为它的版本号比事务A的要大。</p><ul><li><code>MVVC</code> 只能在 <code>Read Committed</code> 和 <code>Repeatable Read</code> 隔离级别下工作。</li><li>在 <code>READ UNCOMMITED</code> 隔离级别下找不到适合它们事务的行版本，所以不兼容。</li><li>在 <code>Serializable</code> 隔离级别下读操作会锁定它们返回的数据，所以也不兼容。</li></ul></blockquote><ol start="4"><li>将数据库事务隔离级别设置成 <code>Serializable</code></li></ol><p>事务A：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 查询账户信息，然后执行事务B</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> account<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 提交事务后，发现事务B执行成功</span><span class="token keyword">commit</span><span class="token punctuation">;</span>                </code></pre><p>事务B：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 开启事务</span><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 无法插入数据，一直在等待事务B提交</span><span class="token keyword">insert</span> account<span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> money<span class="token punctuation">)</span> <span class="token keyword">VALUE</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">,</span> <span class="token number">1100.00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><blockquote><p>虽然 <code>Serializable</code> 是最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是也同样会导致大量超时以及争锁的问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/2019/08/19/hashmap-shi-xian-yuan-li/"/>
      <url>/2019/08/19/hashmap-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><code>HashMap</code> 基于 <code>Map</code> 接口实现，元素以键值对的方式存储，并且允许使用 <code>null</code> 键和 <code>null</code> 值，因为 <code>key</code> 不允许重复，因此只能有一个键为 <code>null</code>， <code>HashMap</code> 不能保证放入元素的顺序，它是<strong>无序的</strong>，和放入的顺序并不能相同。<code>HashMap</code> 是<strong>线程不安全</strong>的。</p></blockquote><p>注：<em>有序存储键值对数据时，可以使用 <code>LinkedHashMap</code>；要保证线程安全时，可以使用 <code>ConcurrentHashMap</code>。</em></p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><blockquote><p><code>HashMap</code> 由<strong>数组</strong>和<strong>链表</strong>来实现对数据的存储。<code>HashMap</code> 采用 <code>Entry</code> 数组来存储键值对，每一个键值对组成了一个 <code>Entry</code> 实体，<code>Entry</code> 类实际上是一个单向的链表结构，它具有 <code>Next</code> 指针，可以连接下一个 <code>Entry</code> 实体，以此来解决 <code>Hash</code> 冲突的问题。</p></blockquote><ol><li>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：查找容易，插入和删除困难。</li><li>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O(N)。链表的特点是：查找困难，插入和删除容易。</li></ol><p>注：<em><code>HashMap</code> 里面实现一个静态内部类 <code>Entry</code>，其重要的属性有 <code>hash</code>，<code>key</code>，<code>value</code>，<code>next</code>。</em></p><p><code>HashMap</code> 存储规则：每个元素存储的是一个链表的头结点。那么一个长度16的数组中，元素是按照什么规则存放到数组中呢。是通过元素的 <code>key</code> 的哈希值（<code>key</code> 的 <code>hashcode</code> 进行二次 <code>hash</code>）对数组长度 - 1的位运算得到存储位置的下标。比如哈希值8（8 &amp; (16 - 1) = 8）、12（12 &amp; (16 - 1) = 12）、40（40 &amp; (16 - 1) = 8）、140（140 &amp; (16 - 1) = 12），所以8和40存储在数组下标为8的位置；12和140存储在数组下标为12的位置。</p><p><code>HashMap</code> 链式数据结构：<code>Entry</code> 类中有一个 <code>next</code> 属性，指向下一个 <code>Entry</code>。比如第一个键值对A进来，通过计算其 <code>key</code> 的 <code>hash</code> 得到的index = 0，记做：<em>Entry[0] = A</em>；此时又有一个键值对B进来，通过计算得到的index也等于0，此时 <code>HashMap</code> 会使得<em>Entry[0] = B</em>，<em>B.next = A</em>；若这时又进来一个键值对C，同样的index等于0，此时 <code>HashMap</code> 会使得<em>Entry[0] = C</em>，<em>C.next = B</em>；index = 0的位置存储了A、B、C三个键值对，它们之间通过 <code>next</code> 这个属性链接在一起，所以<strong>数组中存储的是最后插入的元素，先插入的元素终会被放到Entry链的尾部</strong>，这里你也就明白为什么 <code>HashMap</code> 是无序的了吧。</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><blockquote><p>添加元素时，会判断当前元素个数，当大于等于阈值（数组的长度 * 加载因子的值）时，就会自动扩容。扩容就是重新计算容量，但是 <code>Java</code> 中数组是无法自动扩容的，所以需要新的数组代替已有的容量小的数组。</p></blockquote><p><em>比如长度为16的数组，加载因子为0.75，则阈值为 <code>16 * 0.75 = 12</code>，也就是说当元素个数达到12，在添加第13个元素时会进行扩容。即  <code>16 * 2 = 32</code>，那么扩容后的容量是32。这里先抛出一个问题，为什么每次扩容都在原有容量乘以2，继续往下看。</em></p><p>注：<code>HashMap</code> 使用的是懒加载，构造完 <code>HashMap</code> 对象后，只要不进行 <code>put</code> 方法插入元素之前，<code>HashMap</code> 并不会去初始化或者扩容。</p><p>问题：为什么容量大小为2的n次幂效率最好？</p><table><thead><tr><th align="left">&amp; 1111</th><th align="center">8</th><th align="center">9</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="left">hashcode值</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td></tr><tr><td align="left">数组长度 - 1</td><td align="center">1  1  1  1</td><td align="center">1  1  1  1</td><td align="center">1  1  1  0</td><td align="center">1  1  1  0</td></tr><tr><td align="left">结果</td><td align="center">1  0  0  0</td><td align="center">1  0  0  1</td><td align="center">1  0  0  0</td><td align="center">1  0  0  0</td></tr></tbody></table><p>如上表，左边两组是数组长度为16(2的4次幂)，右边两组是数组长度为15。两组的 <code>hashcode</code> 均为8 和 9，然而与 <code>1110</code> 做位运算时，产生相同的结果，也是会存储到数组的同一个位置上，这就产生了碰撞，8 和 9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，降低了查询的效率。我们还可以发现，当数组长度为15的时候，<code>hashcode</code> 的值会与14（1110）进行位运算，最后一位永远是0，那 <code>0001</code>，<code>0011</code>，<code>0101</code>，<code>1001</code>，<code>1011</code>，<code>0111</code>，<code>1101</code>这几个位置永远都不能存放元素，浪费空间。数组可使用的位置比数组长度小很多，这样会增加碰撞的几率，减慢查询的效率。</p><blockquote><p>数组长度为2的n次幂的时候，不同的 <code>key</code> 算得的 <code>index</code> 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了，所以在存储大容量数据时，最好预先指定容量大小为2的n次幂（其实不指定为2的n次幂的话，HashMap也会以大于且最接近指定值大小的2的n次幂进行初始化），也解释了上面问题，为什么 <code>HashMap</code> 每次扩容都在原有容量上乘以2。</p></blockquote><p>扩容是一个特别耗性能的操作，所以在使用 <code>HashMap</code> 的时候，估算 <code>map</code> 的大小，初始化的时候给一个大致的数值，避免 <code>map</code> 进行频繁的扩容。那么这个数值多少才是最合适的值呢，下面看一个例子。</p><p>例：假如有1000个元素需要存储到 <code>HashMap</code> 中，那么根据上面提到的容量大小为2的n次幂效率最好，那么 <code>new HashMap(1024)</code> 是比较合适的，但是上面也提到了，当存储元素达到阈值时，<code>HashMap</code> 会进行扩容，那么1024 * 0.75 &lt; 1000，所以为了不进行扩展，需要size * 0.75 &gt; 1000，那么可以得出 <code>new HashMap(2048)</code> 才是最合适的。 </p><h3 id="重写-hashcode-和-equals-方法"><a href="#重写-hashcode-和-equals-方法" class="headerlink" title="重写 hashcode 和 equals 方法"></a>重写 hashcode 和 equals 方法</h3><p>疑问：为什么要重写 <code>hashcode</code> 和 <code>equals</code> 方法？</p><p>根据上面介绍，我们知道想查找某个元素，就需要先获取其所在位置，那么首先计算 <code>key</code> 的 <code>hashcode</code>，找到其在数组中对应的位置，然后通过 <code>key</code> 的 <code>equals</code> 方法在对应位置的链表中找到元素。因此 <code>hashcode</code> 与 <code>equals</code> 方法对于找到对应元素是两个关键方法。 </p><p>重写 <code>equals</code> 方法需要满足三个条件：</p><ol><li>自反性：a.equals(a) == true。 </li><li>对称性：a.equals(b) == true时，b.equals(a) 也为 true。 </li><li>传递性：a.equals(b) == true时，且b.equals(c) == true，那么 a.equals(c) 也要为 true。 </li></ol><h3 id="JDK-1-8-优化"><a href="#JDK-1-8-优化" class="headerlink" title="JDK 1.8 优化"></a>JDK 1.8 优化</h3><blockquote><p>以上都是基于 <code>JDK 1.7</code> 进行分析的，<code>JDK 1.8</code> 在 <code>HashMap</code> 实现方式上做了一些优化。数据结构的存储由数组+链表的方式，变化为数组+链表+红黑树的存储方式，当链表长度超过阈值（8）时，将链表转换为红黑树。性能上有了提升。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/2019/08/14/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2019/08/14/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></h3><blockquote><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。<code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></h3><blockquote><p><code>GitHub</code> 是一个面向开源及私有软件项目的托管平台，因为只支持 <code>git</code> 作为唯一的版本库格式进行托管，故名 <code>GitHub</code>。</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h5 id="检查是否安装-Git，在-Dos-窗口下，执行下面命令。"><a href="#检查是否安装-Git，在-Dos-窗口下，执行下面命令。" class="headerlink" title="检查是否安装 Git，在 Dos 窗口下，执行下面命令。"></a>检查是否安装 <code>Git</code>，在 <code>Dos</code> 窗口下，执行下面命令。</h5><pre class=" language-dos"><code class="language-dos">git --version</code></pre><h5 id="检查是否安装-Node-js，在-Dos-窗口下，执行下面命令。"><a href="#检查是否安装-Node-js，在-Dos-窗口下，执行下面命令。" class="headerlink" title="检查是否安装 Node.js，在 Dos 窗口下，执行下面命令。"></a>检查是否安装 <code>Node.js</code>，在 <code>Dos</code> 窗口下，执行下面命令。</h5><pre class=" language-dos"><code class="language-dos">node -v</code></pre><blockquote><p> 如果没有安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>和<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a>，到官网自行下载安装，这里不作过多介绍，网上教程也比较多。安装过 <code>Git</code>，以下命令操作都统一使用 <code>Git Bash Here</code> 执行。</p></blockquote><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><h5 id="1-安装-Hexo-扩展插件，在-Git-Bash-Here-窗口下，执行下面命令。"><a href="#1-安装-Hexo-扩展插件，在-Git-Bash-Here-窗口下，执行下面命令。" class="headerlink" title="1. 安装 Hexo 扩展插件，在 Git Bash Here 窗口下，执行下面命令。"></a>1. 安装 <code>Hexo</code> 扩展插件，在 <code>Git Bash Here</code> 窗口下，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g</code></pre><h5 id="2-创建一个-blog-文件夹，存放-hexo-相应的代码。"><a href="#2-创建一个-blog-文件夹，存放-hexo-相应的代码。" class="headerlink" title="2. 创建一个 blog 文件夹，存放 hexo 相应的代码。"></a>2. 创建一个 <code>blog</code> 文件夹，存放 <code>hexo</code> 相应的代码。</h5><pre class=" language-bash"><code class="language-bash">$ hexo init blog</code></pre><h5 id="3-进入-blog-文件夹。"><a href="#3-进入-blog-文件夹。" class="headerlink" title="3. 进入 blog 文件夹。"></a>3. 进入 <code>blog</code> 文件夹。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> blog</code></pre><h5 id="4-安装-hexo-相关代码。"><a href="#4-安装-hexo-相关代码。" class="headerlink" title="4. 安装 hexo 相关代码。"></a>4. 安装 <code>hexo</code> 相关代码。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>下面介绍下相关文件</p><pre class=" language-yaml"><code class="language-yaml">node_modules          npm 文件缓存目录scaffolds             文夹件下存放的是文章、页面模版scource               文夹件下存放的是我们的资源文件themes                文件下存放的是我们的主题文件.gitignore            git 忽略文件，设置提交文件时，哪些文件不提交_config.yml           站点配置文件package.json          站点版本，站点依赖文件package<span class="token punctuation">-</span>lock.json     npm 各库包的依赖</code></pre><h5 id="5-启动本地服务，打开-http-localhost-40000-则可以看到博客雏形了。"><a href="#5-启动本地服务，打开-http-localhost-40000-则可以看到博客雏形了。" class="headerlink" title="5. 启动本地服务，打开 http://localhost:40000 则可以看到博客雏形了。"></a>5. 启动本地服务，打开 <a href="http://localhost:40000/" target="_blank" rel="noopener">http://localhost:40000</a> 则可以看到博客雏形了。</h5><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><h3 id="修改-Hexo-主题"><a href="#修改-Hexo-主题" class="headerlink" title="修改 Hexo 主题"></a>修改 Hexo 主题</h3><h5 id="1-将主题拉到本地，并解压，执行下面命令。"><a href="#1-将主题拉到本地，并解压，执行下面命令。" class="headerlink" title="1. 将主题拉到本地，并解压，执行下面命令。"></a>1. 将主题拉到本地，并解压，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> themes$ <span class="token function">git</span> clone hexo主题GitHub地址</code></pre><h5 id="2-配置-config-yml-的-theme-配置。"><a href="#2-配置-config-yml-的-theme-配置。" class="headerlink" title="2. 配置 _config.yml 的 theme 配置。"></a>2. 配置 <code>_config.yml</code> 的 <code>theme</code> 配置。</h5><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> hexo主题文件夹名</code></pre><h5 id="3-启动站点，执行下面命令。"><a href="#3-启动站点，执行下面命令。" class="headerlink" title="3. 启动站点，执行下面命令。"></a>3. 启动站点，执行下面命令。</h5><pre class=" language-yaml"><code class="language-yaml">cd ..  <span class="token comment" spellcheck="true">#回退到blog文件夹</span>hexo g <span class="token comment" spellcheck="true"># 或者 hexo generate</span>hexo s</code></pre><blockquote><p> 运行上述命令后，浏览器打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可本地访问我们的网站。相关配置修改可以参考你选择的 <code>hexo</code> 主题介绍。<br> 这时候你肯定会问现在博客只能本地访问，那如何能放到网上让其他人也可以访问我的博客呢？下面我们就用 <code>GitHub</code> 来充当我们的服务器，如果你还没有 <code>GitHub</code> 账号，此时你需要注册一个，网上教程很多，这里就不介绍了。</p></blockquote><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><h5 id="1-点击右上角-号，然后点击-New-repository-添加仓库。"><a href="#1-点击右上角-号，然后点击-New-repository-添加仓库。" class="headerlink" title="1. 点击右上角 + 号，然后点击  New repository 添加仓库。"></a>1. 点击右上角 <code>+</code> 号，然后点击  <code>New repository</code> 添加仓库。</h5><p><img src="http://chuantu.xyz/t6/702/1565790257x2890171739.png" alt></p><h5 id="2-打开网址-https-Ownner-gihub-io-则可以看到你的-GitHub-Page，这个就是你的-服务器"><a href="#2-打开网址-https-Ownner-gihub-io-则可以看到你的-GitHub-Page，这个就是你的-服务器" class="headerlink" title="2. 打开网址 https://Ownner.gihub.io 则可以看到你的 GitHub Page，这个就是你的 服务器"></a>2. 打开网址 <a href="https://Ownner.gihub.io" target="_blank" rel="noopener">https://Ownner.gihub.io</a> 则可以看到你的 <code>GitHub Page</code>，这个就是你的 <code>服务器</code></h5><blockquote><p><code>Owner</code> 需要改成你自己的用户名，像我的则是 <code>tongtong-ge</code>。</p></blockquote><h3 id="修改网站相关设置"><a href="#修改网站相关设置" class="headerlink" title="修改网站相关设置"></a>修改网站相关设置</h3><blockquote><p>网站相关设置需要在 <code>_config.yml</code> 里进行修改。对应目录为 <code>blog/_config.yml</code>。找到 <code>GitHub</code> 仓库对应的 <code>SSH</code> 地址，把 <code>SSH</code> 地址添加到 <code>depoly</code>-<code>repo</code> 配置上。</p></blockquote><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git   <span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>Owner.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><h3 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h3><h5 id="1-生成静态文件，执行下面命令。"><a href="#1-生成静态文件，执行下面命令。" class="headerlink" title="1. 生成静态文件，执行下面命令。"></a>1. 生成静态文件，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ hexo g</code></pre><h5 id="2-提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。"><a href="#2-提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。" class="headerlink" title="2. 提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。"></a>2. 提交到远程仓库，提交之前需要安装一个扩展插件，执行下面命令。</h5><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save <span class="token comment" spellcheck="true">#安装扩展插件</span>$ hexo d <span class="token comment" spellcheck="true">#提交到远程仓库</span></code></pre><blockquote><p>执行完之后，此时你就可以在 <code>GitHub</code> 上看到提交的静态文件，同时通过 <a href="https://Owner.github.io" target="_blank" rel="noopener">https://Owner.github.io</a> 就可以访问我们的博客了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/14/hello-world/"/>
      <url>/2019/08/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
